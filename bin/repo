#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<EOF >&2
Usage: $(basename "$0") [-s <search>] [-c] <github-org>/<github-repo>

If -s <search> is provided the script searches subfolders of $HOME/repositories for
folders containing the search string (case-insensitive), presents the results as
choices via the `prompt` helper, and echoes the selected folder path.

Otherwise, when given <org>/<repo> it checks for $HOME/repositories/github.com/<org>/<repo>,
and if missing, clones https://github.com/<org>/<repo>.git into that location and prints the path.

If -c is provided, opens VS Code in the target folder after determining the path.
EOF
  exit 2
}

# script_dir: location of this script (to find companion scripts like prompt)
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

search=""
open_code=false
while getopts ":s:c" opt; do
  case "$opt" in
    s) search="$OPTARG" ;;
    c) open_code=true ;;
    *) usage ;;
  esac
done
shift $((OPTIND-1))

if [ -n "$search" ]; then
  # Search mode
  if [ ! -d "$HOME/repositories" ]; then
    echo "Error: $HOME/repositories does not exist" >&2
    exit 4
  fi
  # Find org/repo directories (depth 3: github.com/org/repo) and filter by search string (case-insensitive)
  mapfile -t matches < <(find "$HOME/repositories" -mindepth 3 -maxdepth 3 -type d 2>/dev/null | grep -i -- "$search" || true)
  if [ "${#matches[@]}" -eq 0 ]; then
    echo "No matches for '$search'" >&2
    exit 4
  fi
  # Use prompt helper to let the user choose
  if [ ! -x "$script_dir/prompt" ]; then
    echo "Error: prompt helper not found or not executable: $script_dir/prompt" >&2
    exit 5
  fi
  # Build newline-separated options string
  options_str=$(printf '%s\n' "${matches[@]}")
  if ! selection="$($script_dir/prompt "Select repository" "$options_str")"; then
    # prompt returned non-zero (e.g., cancelled)
    exit 1
  fi
  printf '%s\n' "$selection"
  if [ "$open_code" = true ]; then
    if command -v code >/dev/null 2>&1; then
      code "$selection"
    else
      echo "Warning: 'code' command not found, skipping VS Code open" >&2
    fi
  fi
  exit 0
fi

if [ "$#" -ne 1 ]; then
  usage
fi

arg="$1"
if ! [[ "$arg" =~ ^[^/]+/[^/]+$ ]]; then
  echo "Error: expected argument in form <org>/<repo>; got: $arg" >&2
  usage
fi

org="${arg%%/*}"
repo="${arg##*/}"

base="$HOME/repositories/github.com/$org"
target="$base/$repo"

# If target already exists, print and exit
if [ -d "$target" ]; then
  printf '%s\n' "$target"
  if [ "$open_code" = true ]; then
    if command -v code >/dev/null 2>&1; then
      code "$target"
    else
      echo "Warning: 'code' command not found, skipping VS Code open" >&2
    fi
  fi
  exit 0
fi

# Need git
if ! command -v git >/dev/null 2>&1; then
  echo "Error: git is required to clone repositories" >&2
  exit 3
fi

mkdir -p -- "$base"

remote="https://github.com/$org/$repo.git"

# Verify remote exists (fail early)
if ! git ls-remote --exit-code "$remote" >/dev/null 2>&1; then
  # Remote doesn't exist; ask before creating a new repo locally
  echo "Remote not found: $remote" >&2
  if [ ! -x "$script_dir/confirm" ]; then
    echo "Error: confirm helper not found or not executable: $script_dir/confirm" >&2
    exit 5
  fi
  response="$($script_dir/confirm "Create new repository at $target?")"
  if [ "$response" != "y" ]; then
    echo "Aborted by user; not creating $target" >&2
    exit 1
  fi
  echo "Creating new local repository at: $target" >&2
  if git init "$target"; then
    printf '%s\n' "$target"
    if [ "$open_code" = true ]; then
      if command -v code >/dev/null 2>&1; then
        code "$target"
      else
        echo "Warning: 'code' command not found, skipping VS Code open" >&2
      fi
    fi
    exit 0
  else
    echo "Error: git init failed for $target" >&2
    exit 5
  fi
fi

# Clone into the target directory
if git clone "$remote" "$target"; then
  printf '%s\n' "$target"
  if [ "$open_code" = true ]; then
    if command -v code >/dev/null 2>&1; then
      code "$target"
    else
      echo "Warning: 'code' command not found, skipping VS Code open" >&2
    fi
  fi
  exit 0
else
  echo "Error: git clone failed for $remote" >&2
  # clean up partial clone if any
  rm -rf -- "$target" || true
  exit 5
fi
